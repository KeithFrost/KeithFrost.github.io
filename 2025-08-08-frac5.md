---
summary: >-
  My journey to using Numerical Elixir to generate a new type of flame fractal.
---

# Frac5: A new type of flame fractal

![example frac5 fractal image](/images/fractal255.png)

This article describes my journey from generating flame fractals using
[Elixir](https://elixir-lang), to generating a new type of
(flame-ish?) fractal in [Numerical
Elixir](https://github.com/elixir-nx).  The code is published as a GPL
Elixir library at
[github.com/KeithFrost/frac5](https://github.com/KeithFrost/frac5).


This summer I've been working on personal projects at the [Recurse
Center](https://recurse.com) (RC).  Part of the RC application process
involves pitching at least one project that you plan to work on.  The
[frac5](https://github.com/KeithFrost/frac5) project was inspired by
the pitch I wrote for my RC application.

To give due credit, the work I describe here would not exist without
Danielle Navarro's terrific article [Art from code V: Iterated
function
systems](https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/)
(hereinafter referred to as *AFC5*); I'm going to summarize only those
parts of their article which I used for my starting point, but I
encourage you to read the whole thing for edification and inspiration.

I had been using [Elixir](https://elixir-lang) for personal projects
for a while, because I find programming with it elegant and fun; I
especially enjoy prototyping code using [Elixir
Livebook](https://livebook.dev) running locally.  I had read about
[Numerical Elixir](https://github.com/elixir-nx), which extends the
language to make it possible to perform the kind of efficient
numerical programming often done with [NumPy](https://numpy.org),
[PyTorch](https://pytorch.org), or similar libraries, but I had not
found a use case to motivate learning how to program it myself.  I
came across
[*AFC5*](https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/),
enjoyed the beautiful images they were able to generate (especially
those at the end of the article), and was a little uncomfortable about
needing to resort to writing C++ to generate those detailed images
quickly.  My initial plan was to retrace their steps using only
Elixir, and then explore if there was some way to use Numerical Elixir
to accelerate the image generation.


## Iterated function systems

I will now briefly recap how the beautiful images at the end of *AFC5*
are generated, although if you want to reproduce all the details from
that article precisely, you should of course refer to it, and the code
it provides, directly.

Those images are generated by starting with a single point $p_0$
in a three-dimensional space ${p_0 \equiv (x_0, y_0, z_0)}$.  In what
follows, we will refer to the coordinates of these points by a
second index, so we have
$$
p_0 \equiv (p_{0,0}, p_{0,1}, p_{0,2}) \equiv (x_0, y_0, z_0)
$$

The point $p_0$ is then passed through a series of transformations,
alternating between linear and non-linear steps, and after each
non-linear step, the resulting point is added into the collection of
points to be rendered.

In effect, we generate a collection of points $\{p_k\}, k=0,1,2,...$,
where
$$
p_{k} = f_k\left( \sum_j A_{k,i,j} \cdot p_{k-1,j} \right).
$$
The meaning of the linear transformation here should be clear:
$$
q_{k,i} = \sum_{j=0}^2 A_{k,i,j} \cdot p_{k-1,j}, i = 0,1,2.
$$
defines a new 3-D vector $q_k$ by multiplying the 3-D vector $p_{k-1}$
by a $3 \times 3$ matrix $A_k$.
What we mean by $p_k = f_k(q_{k,i})$ perhaps needs some
clarification. The general function $f_k$ is understood to accept as arguments
*all three of the components* of the 3-D vector $q_k$, and return *all
three of the components* of the 3-D vector $p_k$.

In the iterated systems discussed at the end of *AFC5*, the
transformation matrix $A_k$ at each stage $k = 1,2,3,...$ is randomly
chosen from a set of matrices $\{M_q\}, q=1,2,...m$, and the function
$f_k(q_k)$ is likewise randomly chosen from a set of non-linear
transformations $\{G_r(q)\}$, defined in *AFC5* as
$$
\begin{align}
G_{0,i}(q) &= q_i + \left( \sum_j q_j^2 \right)^{1/3} \\
G_{1,i}(q) &= \sin(q_i) \\
G_{2,i}(q) &= 2 \cdot \sin(q_i)
\end{align}
$$

I have taken the liberty here of eliding some manipulations performed
in the original *AFC5* article, which treat the $z$ coordinate of the
points specially, to ensure that the $z$ coordinate always remains
non-negative, and to average the new $z$ coordinate $p_{k,2}$ with its
previous value $p_{k-1,2}$ before finalizing its value.  These details
might be important if you wish to reproduce the results of that
article in detail, but for understanding the extension of that work to
follow, it seems best to me to treat all dimensions of the vector
space symmetrically, until we are ready to render the pixel data of
the image.

Speaking of being ready to render pixel data, we have seen how we can
generate an arbitrarily large collection of points $\{p_k\},
k=0,1,2,...$, but how do we turn those points into an image?  In the
algorithm described in *ACS5*, we transform the $(x, y)$ coordinates
of the points into indices of a two-dimensional pixel array, and then,
if those indices fall within the bounds of the array, set the color of
the pixel referenced by those indices to a value determined by some
chosen palette for converting $z$ values to colors.

I found I was able to reproduce, as closely as I wished, the work in
*ACS5*, by writing code in ordinary Elixir (without using Numerical
Elixir), and it performed well enough to generate some lovely images
within acceptable times.  For example:

![early example fractal](/images/fractal002.png)

As soon as I was able to generate this image (and several others like
it), I became tremendously excited by the potential of the project.  I
knew that there was much more work I could explore along these lines,
by investigating each of the choices that went into creating the
images, and finding ways to either optimize the implementation, or
expand the range of choices available for artistic purposes.  But more
than that, I was supremely motivated by the surprising and spectacular
beauty of the generated pictures, especially when combined with the
stark mathematical simplicity of the means of generating them.  To put
it bluntly, I was hooked.

## Porting to Numerical Elixir
