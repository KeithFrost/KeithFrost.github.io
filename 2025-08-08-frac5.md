---
summary: >-
  My journey to using Numerical Elixir to generate a new type of flame fractal.
---

# Frac5: A new type of flame fractal

![example frac5 fractal image](/images/fractal255.png)

This article describes my journey from generating flame fractals using
[Elixir](https://elixir-lang), to generating a new type of
(flame-ish?) fractal in [Numerical
Elixir](https://github.com/elixir-nx).  The code is published as a GPL
Elixir library at
[github.com/KeithFrost/frac5](https://github.com/KeithFrost/frac5).


This summer I've been working on personal projects at the [Recurse
Center](https://recurse.com) (RC).  Part of the RC application process
involves pitching at least one project that you plan to work on.  The
[frac5](https://github.com/KeithFrost/frac5) project was inspired by
the pitch I wrote for my RC application.

To give due credit, the work I describe here would not exist without
Danielle Navarro's terrific article [Art from code V: Iterated
function
systems](https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/)
(hereinafter referred to as *AFC5*); I'm going to summarize only those
parts of their article which I used for my starting point, but I
encourage you to read the whole thing for edification and inspiration.

I had been using [Elixir](https://elixir-lang) for personal projects
for a while, because I find programming with it elegant and fun; I
especially enjoy prototyping code using [Elixir
Livebook](https://livebook.dev) running locally.  I had read about
[Numerical Elixir](https://github.com/elixir-nx), which extends the
language to make it possible to perform the kind of efficient
numerical programming often done with [NumPy](https://numpy.org),
[PyTorch](https://pytorch.org), or similar libraries, but I had not
found a use case to motivate learning how to program it myself.  I
came across
[*AFC5*](https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/),
enjoyed the beautiful images they were able to generate (especially
those at the end of the article), and was a little uncomfortable about
needing to resort to writing C++ to generate those detailed images
quickly.  My initial plan was to retrace their steps using only
Elixir, and then explore if there was some way to use Numerical Elixir
to accelerate the image generation.


## Iterated function systems

I will now briefly recap how the beautiful images at the end of *AFC5*
are generated, although if you want to reproduce all the details from
that article precisely, you should of course refer to it, and the code
it provides, directly.

Those images are generated by starting with a single point $p_0$
in a three-dimensional space ${p_0 \equiv (x_0, y_0, z_0)}$.  In what
follows, we will refer to the coordinates of these points by a
second index, so we have
$$
p_0 \equiv (p_{0,0}, p_{0,1}, p_{0,2}) \equiv (x_0, y_0, z_0)
$$

The point $p_0$ is then passed through a series of transformations,
alternating between linear and non-linear steps, and after each
non-linear step, the resulting point is added into the collection of
points to be rendered.

In effect, we generate a collection of points $\{p_k\}, k=0,1,2,...$,
where
$$
p_{k} = f_k\left( \sum_j A_{k,i,j} \cdot p_{k-1,j} \right).
$$
The meaning of the linear transformation here should be clear:
$$
q_{k,i} = \sum_{j=0}^2 A_{k,i,j} \cdot p_{k-1,j}, i = 0,1,2.
$$
defines a new 3-D vector $q_k$ by multiplying the 3-D vector $p_{k-1}$
by a $3 \times 3$ matrix $A_k$.
What we mean by $p_k = f_k(q_{k,i})$ perhaps needs some
clarification. The general function $f_k$ is understood to accept as arguments
*all three of the components* of the 3-D vector $q_k$, and return *all
three of the components* of the 3-D vector $p_k$.

In the iterated systems discussed at the end of *AFC5*, the
transformation matrix $A_k$ at each stage $k = 1,2,3,...$ is randomly
chosen from a set of matrices $\{M_q\}, q=1,2,...m$, and the function
$f_k(q_k)$ is likewise randomly chosen from a set of non-linear
transformations $\{G_r(q)\}$, defined in *AFC5* as
$$
\begin{align}
G_{0,i}(q) &= q_i + \left( \sum_j q_j^2 \right)^{1/3} \\
G_{1,i}(q) &= \sin(q_i) \\
G_{2,i}(q) &= 2 \cdot \sin(q_i)
\end{align}
$$

I have taken the liberty here of eliding some manipulations performed
in the original *AFC5* article, which treat the $z$ coordinate of the
points specially, to ensure that the $z$ coordinate always remains
non-negative, and to average the new $z$ coordinate $p_{k,2}$ with its
previous value $p_{k-1,2}$ before finalizing its value.  These details
might be important if you wish to reproduce the results of that
article in detail, but for understanding the extension of that work to
follow, it seems best to me to treat all dimensions of the vector
space symmetrically, until we are ready to render the pixel data of
the image.

Speaking of being ready to render pixel data, we have seen how we can
generate an arbitrarily large collection of points $\{p_k\},
k=0,1,2,...$, but how do we turn those points into an image?  In the
algorithm described in *ACS5*, we transform the $(x, y)$ coordinates
of the points into indices of a two-dimensional pixel array, and then,
if those indices fall within the bounds of the array, set the color of
the pixel referenced by those indices to a value determined by some
chosen palette for converting $z$ values to colors.

I found I was able to reproduce, as closely as I wished, the work in
*ACS5*, by writing code in ordinary Elixir (without using Numerical
Elixir), and it performed well enough to generate some lovely images
within acceptable times.  For example:

![first fractal I made, using a palette](/images/fractal002.png)

As soon as I was able to generate this image (and several others like
it), I became tremendously excited by the potential of the project.  I
knew that there was much more work I could explore along these lines,
by investigating each of the choices that went into creating the
images, and finding ways to either optimize the implementation, or
expand the range of choices available for artistic purposes.  But more
than that, I was supremely motivated by the surprising and spectacular
beauty of the generated pictures, especially when combined with the
stark mathematical simplicity of the means of generating them.  To put
it bluntly, I was hooked.

## Porting to Numerical Elixir

While it is possible to generate interesting and beautiful images
using only a few million points using the scheme described in *ACS5*,
more subtle and complex textures become possible by scaling the number
of points up to hundreds of millions.  And while it is possible to
process such large numbers of points on a CPU using a language like
Elixir, such "number-crunching" applications are not the forte of the
language, and it soon becomes tedious to wait for the image generation
process.  The author of *ACS5* opted to port the algorithm to C++ to
achieve better speed; I wanted to find out if it might be possible to
do so using the features of Numerical Elixir, especially with a
backend programmed to use a GPU.

I quickly realized that there was a significant obstacle to achieving
a significant performance improvement of the fractal algorithm
presented above using `Nx`, particularly on the GPU.  Many of the
performance benefits achieved by libraries like `Nx`, which manipulate
numbers in large, often multi-dimensional arrays, come from being able
to compute operations on many elements of these arrays *in parallel*.
This is *especially* true for the performance enhancements provided by
using the GPU.  But recall the algorithm presented above, in which we
might wish to process hundreds of millions of points $\{p_k\},
k=0,1,2...$, defined *in sequence* by some transformation $p_{k-1}
\rightarrow p_k$.  If the components of each point $p_k$ depend on
some random choices *and the components of the preceding point*
$p_{k-1}$, we cannot achieve any high degree of parallelism of the
processing of these points, since a processor (either CPU or GPU)
cannot process a point until the values from the preceding point (and
the random choices) are available.

One means of circumventing this difficulty would seem to be, to
replace the single starting point $p_0$ with an ensemble of starting
points, and to achieve the efficiencies of parallelism by collecting
ensembles of points processed through the steps of the algorithm in
parallel.  Unfortunately, my experiments with implementing this
approach convinced me that the results did not successfully reproduce
the aesthetic features of the beautiful images generated by the
original algorithm.

Instead, inspired by another variation on the algorithm I had
explored, I decided to try something else.  Recall above that there
were two distinct random choices made for each transformation of the
points: first, a random matrix was chosen for the linear
transformation, and second, a random non-linear transformation was
chosen.  I had already experimented with replacing the random choice
of matrix with a simple repeating sequence of matrices.  To transform
the point $p_k$, for example, we might use the matrix $M_{k
\bmod m}$, where $m$ is the number of random matrices initially
generated.  This gave results which were just as beautiful as the
random choice algorithm.

So when I thought about how to make the algorithm more suitable to
parallel computation, I was already primed to consider modifying the
random choice rule.  In particular, I opted to try, instead of
randomly choosing *one* of the non-linear transformations available,
to always perform *all* of the non-linear transformations, and to add
all of the points thus generated, both to the set of points used to
render the image, and to an ensemble of points to be passed to the
next stage of the algorithm.  This means that the number of points in
the ensemble at each stage of the algorithm grows exponentially with
each such application of the non-linear transformations.  When the
ensemble of points grows sufficiently large, I split it up into
batches, in order to avoid having any one block of memory need to be
too large.  Since blocks of points can be discarded once they are
accumulated into the grid used to generate the image pixels, and
Elixir allows me to generate a lazy stream of blocks of points for
accumulation into the grid, this helps to keep memory usage of the
program at any one time under control.

I found removing all of the random choices from the execution of the
algorithm in this way both aesthetically and intellectually pleasing.
I now had a *deterministic* algorithm for generating beautiful images,
given only a sequence of $3 \times 3$ matrices, a set of arbitrary
(usually non-linear) point transformations to be applied, and a color
palette for mapping $z$ values to colors.  Moreover, the algorithm
could be made to transform enormous numbers of points in parallel,
opening the door to making it possible to accelerate it by running on
GPU hardware.  But I still wasn't quite satisfied with the generality
of the mathematics.  In particular, I wanted to use a wider variety of
color palettes than those I had yet defined, and I was uncomfortable
with the tedium and what seemed to me the arbitrariness of the choices
involved in creating new palettes.

One day I went for a walk, and reflected on how I might remove the
need to define a color palette for rendering.  After a couple miles of
walking, I was struck with an idea.  Instead of a three dimensional
space $(x,y,z)$, I would process points in a completely analogous way,
but in a five dimensional space $(x,y,r,g,b)$.  When it came time to
render these points to pixel colors, all I would need is a single
choice of mapping function from color space coordinate to the
corresponding range of pixel values (_e.g._ $[0,255]$). Below is the
very first image I generated using this new scheme.

![first 5-D fractal image](/images/fractal041.png)
