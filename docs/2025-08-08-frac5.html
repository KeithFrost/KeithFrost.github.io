<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-08-08" />
  <title>Frac5: A new type of flame fractal</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #073642;
        color: #839496;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #839496;  padding-left: 4px; }
    div.sourceCode
      { color: #839496; background-color: #002b36; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #d33682; font-weight: bold; } /* Alert */
    code span.an { color: #dc322f; } /* Annotation */
    code span.at { color: #b58900; } /* Attribute */
    code span.bn { color: #2aa198; } /* BaseN */
    code span.bu { color: #859900; } /* BuiltIn */
    code span.cf { color: #859900; } /* ControlFlow */
    code span.ch { color: #dc322f; } /* Char */
    code span.cn { color: #2aa198; } /* Constant */
    code span.co { color: #586e75; font-style: italic; } /* Comment */
    code span.cv { color: #268bd2; } /* CommentVar */
    code span.do { color: #2aa198; } /* Documentation */
    code span.dt { color: #cb4b16; } /* DataType */
    code span.dv { color: #2aa198; } /* DecVal */
    code span.er { color: #ffffff; background-color: #ff0000; } /* Error */
    code span.ex { color: #839496; } /* Extension */
    code span.fl { color: #2aa198; } /* Float */
    code span.fu { color: #268bd2; } /* Function */
    code span.im { color: #2aa198; } /* Import */
    code span.in { color: #2aa198; } /* Information */
    code span.kw { color: #859900; } /* Keyword */
    code span.op { color: #859900; } /* Operator */
    code span.ot { color: #859900; } /* Other */
    code span.pp { color: #cb4b16; } /* Preprocessor */
    code span.re { color: #cb4b16; } /* RegionMarker */
    code span.sc { color: #dc322f; } /* SpecialChar */
    code span.ss { color: #268bd2; } /* SpecialString */
    code span.st { color: #2aa198; } /* String */
    code span.va { color: #cb4b16; } /* Variable */
    code span.vs { color: #2aa198; } /* VerbatimString */
    code span.wa { color: #dc322f; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="/pbb.css" />
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,400i,700,700i|Source+Sans+Pro:400,400i,700,700i&display=swap" rel="stylesheet">
  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="kfrost Feed">
  <link rel="icon" href="/favicon.png" sizes="32x32" type="image/png">
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div id="blogtitle"><a href="./">kfrost</a></div>
<header id="title-block-header">
<h1 class="title">Frac5: A new type of flame fractal</h1>
<p class="date">2025-08-08</p>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">table of contents</h2>
<ul>
<li><a href="#iterated-function-systems"
id="toc-iterated-function-systems">Iterated function systems</a></li>
<li><a href="#porting-to-numerical-elixir"
id="toc-porting-to-numerical-elixir">Porting to Numerical
Elixir</a></li>
<li><a href="#welcome-to-the-5th-dimension"
id="toc-welcome-to-the-5th-dimension">Welcome to the 5th
dimension</a></li>
<li><a href="#themes-and-variations"
id="toc-themes-and-variations">Themes and variations</a></li>
<li><a href="#a-walk-through-the-code"
id="toc-a-walk-through-the-code">A walk through the code</a>
<ul>
<li><a href="#frac5.affine"
id="toc-frac5.affine"><code>Frac5.Affine</code></a></li>
<li><a href="#frac5.transforms"
id="toc-frac5.transforms"><code>Frac5.Transforms</code></a></li>
<li><a href="#frac5.pixels"
id="toc-frac5.pixels"><code>Frac5.Pixels</code></a></li>
</ul></li>
<li><a href="#future-plans" id="toc-future-plans">Future Plans</a></li>
</ul>
</nav>
<figure>
<img src="/images/fractal255.png" alt="example frac5 fractal image" />
<figcaption aria-hidden="true">example frac5 fractal image</figcaption>
</figure>
<p>This article describes my journey from generating flame fractals
using <a href="https://elixir-lang">Elixir</a>, to generating a new type
of (flame-ish?) fractal in <a
href="https://github.com/elixir-nx">Numerical Elixir</a>. The code is
published as a GPL Elixir library at <a
href="https://github.com/KeithFrost/frac5">github.com/KeithFrost/frac5</a>.</p>
<p>This summer I’ve been working on personal projects at the <a
href="https://recurse.com">Recurse Center</a> (RC). Part of the RC
application process involves pitching at least one project that you plan
to work on. The <a href="https://github.com/KeithFrost/frac5">frac5</a>
project was inspired by the pitch I wrote for my RC application.</p>
<p>To give due credit, the work I describe here would not exist without
Danielle Navarro’s terrific article <a
href="https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/">Art
from code V: Iterated function systems</a> (hereinafter referred to as
<em>AFC5</em>); I’m going to summarize only those parts of their article
which I used for my starting point, but I encourage you to read the
whole thing for edification and inspiration.</p>
<p>I had been using <a href="https://elixir-lang">Elixir</a> for
personal projects for a while, because I find programming with it
elegant and fun; I especially enjoy prototyping code using <a
href="https://livebook.dev">Elixir Livebook</a> running locally. I had
read about <a href="https://github.com/elixir-nx">Numerical Elixir</a>,
which extends the language to make it possible to perform the kind of
efficient numerical programming often done with <a
href="https://numpy.org">NumPy</a>, <a
href="https://pytorch.org">PyTorch</a>, or similar libraries, but I had
not found a use case to motivate learning how to program it myself. I
came across <a
href="https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/"><em>AFC5</em></a>,
enjoyed the beautiful images they were able to generate (especially
those at the end of the article), and was a little uncomfortable about
needing to resort to writing C++ to generate those detailed images
quickly. My initial plan was to retrace their steps using only Elixir,
and then explore if there was some way to use Numerical Elixir to
accelerate the image generation.</p>
<h1 id="iterated-function-systems">Iterated function systems</h1>
<p>I will now briefly recap how the beautiful images at the end of
<em>AFC5</em> are generated, although if you want to reproduce all the
details from that article precisely, you should of course refer to it,
and the code it provides, directly.</p>
<p>Those images are generated by starting with a single point <span
class="math inline">\(p_0\)</span> in a three-dimensional space <span
class="math inline">\({p_0 \equiv (x_0, y_0, z_0)}\)</span>. In what
follows, we will refer to the coordinates of these points by a second
index, so we have <span class="math display">\[
p_0 \equiv (p_{0,0}, p_{0,1}, p_{0,2}) \equiv (x_0, y_0, z_0)
\]</span></p>
<p>The point <span class="math inline">\(p_0\)</span> is then passed
through a series of transformations, alternating between linear and
non-linear steps, and after each non-linear step, the resulting point is
added into the collection of points to be rendered.</p>
<p>In effect, we generate a collection of points <span
class="math inline">\(\{p_k\}, k=0,1,2,...\)</span>, where <span
class="math display">\[
p_{k} = f_k\left( \sum_j A_{k,i,j} \cdot p_{k-1,j} \right).
\]</span> The meaning of the linear transformation here should be clear:
<span class="math display">\[
q_{k,i} = \sum_{j=0}^2 A_{k,i,j} \cdot p_{k-1,j}, i = 0,1,2.
\]</span> defines a new 3-D vector <span
class="math inline">\(q_k\)</span> by multiplying the 3-D vector <span
class="math inline">\(p_{k-1}\)</span> by a <span
class="math inline">\(3 \times 3\)</span> matrix <span
class="math inline">\(A_k\)</span>. What we mean by <span
class="math inline">\(p_k = f_k(q_{k,i})\)</span> perhaps needs some
clarification. The general function <span
class="math inline">\(f_k\)</span> is understood to accept as arguments
<em>all three of the components</em> of the 3-D vector <span
class="math inline">\(q_k\)</span>, and return <em>all three of the
components</em> of the 3-D vector <span
class="math inline">\(p_k\)</span>.</p>
<p>In the iterated systems discussed at the end of <em>AFC5</em>, the
transformation matrix <span class="math inline">\(A_k\)</span> at each
stage <span class="math inline">\(k = 1,2,3,...\)</span> is randomly
chosen from a set of matrices <span class="math inline">\(\{M_q\},
q=1,2,...m\)</span>, and the function <span
class="math inline">\(f_k(q_k)\)</span> is likewise randomly chosen from
a set of non-linear transformations <span
class="math inline">\(\{G_r(q)\}\)</span>, defined in <em>AFC5</em> as
<span class="math display">\[
\begin{align}
G_{0,i}(q) &amp;= q_i + \left( \sum_j q_j^2 \right)^{1/3} \\
G_{1,i}(q) &amp;= \sin(q_i) \\
G_{2,i}(q) &amp;= 2 \cdot \sin(q_i)
\end{align}
\]</span></p>
<p>I have taken the liberty here of eliding some manipulations performed
in the original <em>AFC5</em> article, which treat the <span
class="math inline">\(z\)</span> coordinate of the points specially, to
ensure that the <span class="math inline">\(z\)</span> coordinate always
remains non-negative, and to average the new <span
class="math inline">\(z\)</span> coordinate <span
class="math inline">\(p_{k,2}\)</span> with its previous value <span
class="math inline">\(p_{k-1,2}\)</span> before finalizing its value.
These details might be important if you wish to reproduce the results of
that article in detail, but for understanding the extension of that work
to follow, it seems best to me to treat all dimensions of the vector
space symmetrically, until we are ready to render the pixel data of the
image.</p>
<p>Speaking of being ready to render pixel data, we have seen how we can
generate an arbitrarily large collection of points <span
class="math inline">\(\{p_k\},
k=0,1,2,...\)</span>, but how do we turn those points into an image? In
the algorithm described in <em>ACS5</em>, we transform the <span
class="math inline">\((x, y)\)</span> coordinates of the points into
indices of a two-dimensional pixel array, and then, if those indices
fall within the bounds of the array, set the color of the pixel
referenced by those indices to a value determined by some chosen palette
for converting <span class="math inline">\(z\)</span> values to
colors.</p>
<p>I found I was able to reproduce, as closely as I wished, the work in
<em>ACS5</em>, by writing code in ordinary Elixir (without using
Numerical Elixir), and it performed well enough to generate some lovely
images within acceptable times. For example:</p>
<figure>
<img src="/images/fractal002.png"
alt="first fractal I made, using a palette" />
<figcaption aria-hidden="true">first fractal I made, using a
palette</figcaption>
</figure>
<p>As soon as I was able to generate this image (and several others like
it), I became tremendously excited by the potential of the project. I
knew that there was much more work I could explore along these lines, by
investigating each of the choices that went into creating the images,
and finding ways to either optimize the implementation, or expand the
range of choices available for artistic purposes. But more than that, I
was supremely motivated by the surprising and spectacular beauty of the
generated pictures, especially when combined with the stark mathematical
simplicity of the means of generating them. To put it bluntly, I was
hooked.</p>
<h1 id="porting-to-numerical-elixir">Porting to Numerical Elixir</h1>
<p>While it is possible to generate interesting and beautiful images
using only a few million points using the scheme described in
<em>ACS5</em>, more subtle and complex textures become possible by
scaling the number of points up to hundreds of millions. And while it is
possible to process such large numbers of points on a CPU using a
language like Elixir, such “number-crunching” applications are not the
forte of the language, and it soon becomes tedious to wait for the image
generation process. The author of <em>ACS5</em> opted to port the
algorithm to C++ to achieve better speed; I wanted to find out if it
might be possible to do so using the features of Numerical Elixir,
especially with a backend programmed to use a GPU.</p>
<p>I quickly realized that there was a significant obstacle to achieving
a significant performance improvement of the fractal algorithm presented
above using <code>Nx</code>, particularly on the GPU. Many of the
performance benefits achieved by libraries like <code>Nx</code>, which
manipulate numbers in large, often multi-dimensional arrays, come from
being able to compute operations on many elements of these arrays <em>in
parallel</em>. This is <em>especially</em> true for the performance
enhancements provided by using the GPU. But recall the algorithm
presented above, in which we might wish to process hundreds of millions
of points <span class="math inline">\(\{p_k\},
k=0,1,2...\)</span>, defined <em>in sequence</em> by some transformation
<span class="math inline">\(p_{k-1}
\rightarrow p_k\)</span>. If the components of each point <span
class="math inline">\(p_k\)</span> depend on some random choices <em>and
the components of the preceding point</em> <span
class="math inline">\(p_{k-1}\)</span>, we cannot achieve any high
degree of parallelism of the processing of these points, since a
processor (either CPU or GPU) cannot process a point until the values
from the preceding point (and the random choices) are available.</p>
<p>One means of circumventing this difficulty would seem to be, to
replace the single starting point <span
class="math inline">\(p_0\)</span> with an ensemble of starting points,
and to achieve the efficiencies of parallelism by collecting ensembles
of points processed through the steps of the algorithm in parallel.
Unfortunately, my experiments with implementing this approach convinced
me that the results did not successfully reproduce the aesthetic
features of the beautiful images generated by the original
algorithm.</p>
<p>Instead, inspired by another variation on the algorithm I had
explored, I decided to try something else. Recall above that there were
two distinct random choices made for each transformation of the points:
first, a random matrix was chosen for the linear transformation, and
second, a random non-linear transformation was chosen. I had already
experimented with replacing the random choice of matrix with a simple
repeating sequence of matrices. To transform the point <span
class="math inline">\(p_k\)</span>, for example, we might use the matrix
<span class="math inline">\(M_{k
\bmod m}\)</span>, where <span class="math inline">\(m\)</span> is the
number of random matrices initially generated. This gave results which
were just as beautiful as the random choice algorithm.</p>
<p>So when I thought about how to make the algorithm more suitable to
parallel computation, I was already primed to consider modifying the
random choice rule. In particular, I opted to try, instead of randomly
choosing <em>one</em> of the non-linear transformations available, to
always perform <em>all</em> of the non-linear transformations, and to
add all of the points thus generated, both to the set of points used to
render the image, and to an ensemble of points to be passed to the next
stage of the algorithm. This means that the number of points in the
ensemble at each stage of the algorithm grows exponentially with each
such application of the non-linear transformations. When the ensemble of
points grows sufficiently large, I split it up into batches, in order to
avoid having any one block of memory need to be too large. Since blocks
of points can be discarded once they are accumulated into the grid used
to generate the image pixels, and Elixir allows me to generate a lazy
stream of blocks of points for accumulation into the grid, this helps to
keep memory usage of the program at any one time under control.</p>
<p>I found removing all of the random choices from the execution of the
algorithm in this way both aesthetically and intellectually pleasing. I
now had a <em>deterministic</em> algorithm for generating beautiful
images, given only a sequence of <span class="math inline">\(3 \times
3\)</span> matrices, a set of arbitrary (usually non-linear) point
transformations to be applied, and a color palette for mapping <span
class="math inline">\(z\)</span> values to colors. Moreover, the
algorithm could be made to transform enormous numbers of points in
parallel, opening the door to making it possible to accelerate it by
running on GPU hardware. But I still wasn’t quite satisfied with the
generality of the mathematics. In particular, I wanted to use a wider
variety of color palettes than those I had yet defined, and I was
uncomfortable with the tedium and what seemed to me the arbitrariness of
the choices involved in creating new palettes.</p>
<h1 id="welcome-to-the-5th-dimension">Welcome to the 5th dimension</h1>
<p>One day I went for a walk, and reflected on how I might remove the
need to define a color palette for rendering. After a couple miles of
walking, I was struck with an idea. Instead of a three dimensional space
<span class="math inline">\((x,y,z)\)</span>, I would process points in
a completely analogous way, but in a five dimensional space <span
class="math inline">\((x,y,r,g,b)\)</span>. When it came time to render
these points to pixel colors, all I would need is a single choice of
mapping function from color space coordinate to the corresponding range
of pixel values (<em>e.g.</em> <span
class="math inline">\([0,255]\)</span>). Below is the very first image I
generated using this new scheme.</p>
<figure>
<img src="/images/fractal041.png" alt="my first 5-D fractal image" />
<figcaption aria-hidden="true">my first 5-D fractal image</figcaption>
</figure>
<p>It didn’t take very long, after experimenting with generating these
5-D images, that I determined that, in some sense, three degrees of
freedom in color space was really a bit more than I wanted to have in
most of the final images I was generating. So I modified the rendering
algorithm that accumulated the pixel values, so that it accepted the
points from the 5-D space, but then subtracted from the color components
of each point the portion which was parallel to a chosen (random or
arbitrary) unit vector in the 3-D color space, thus flattening the color
space to a plane perpendicular to that unit vector.</p>
<p>It was around this time that I got a Mac mini to work with, so I
found the <a href="https://github.com/elixir-nx/emlx">EMLX</a> library,
which provides an optimized backend for Numerical Elixir which runs on
the Mac GPU, and I was quite pleased with the performance boost this
gave to the image generation process, allowing me to generate images by
processing roughly 300 million points in just a few seconds.</p>
<p>The effects of flattening the color space, and using as many points
as I wanted, can be seen in the next sample image.</p>
<figure>
<img src="/images/fractal100.png"
alt="interesting colors and lots of points" />
<figcaption aria-hidden="true">interesting colors and lots of
points</figcaption>
</figure>
<h1 id="themes-and-variations">Themes and variations</h1>
<p>If it’s not already clear, I should point out that I experimented
freely with as many aspects of the image generation process as I could
recognize as choices, to discover if I could produce effects that I
found pleasing. When it came time to publish a library of code for this
project, it was rather difficult to decide what choices should be hard
coded, as opposed to keeping the library as flexible as possible, to
support whatever I or other users of the library might want to do with
it in the future.</p>
<p>One of the features of the algorithm that I ended up experimenting
with, was the choice to select the points <em>right after the non-linear
operations</em>, as those to send to the rendering process, as opposed
to the points <em>right after the matrix multiplications</em>. By
performing the non-linear operations first, and sending points to
rendering after the matrix multiplication, the prominent “squares”
(projections of 5-D hypercubes) in the earlier images, which were
artifacts of the <span
class="math inline">\(C\cdot\sin(q_{k,i})\)</span> non-linear
transformations, could be removed, which was a feature I
<em>sometimes</em> wanted. I ended up compromising, by writing the
algorithm so that it sent the points to rendering after the sequential,
<em>usually</em> linear operations, but adding an optional argument to
the function which generates the stream of linear operations, which
allows the caller to specify some other operations (presumably
non-linear) to be interleaved between the linear transformations in the
sequence. The image which heads this article, was generated by simply
rendering points after each linear transformation.</p>
<h1 id="a-walk-through-the-code">A walk through the code</h1>
<p>The core of the library, as currently implemented, is divided into
three major modules: <code>Frac5.Affine</code>,
<code>Frac5.Transforms</code>, and <code>Frac5.Pixels</code>. There are
two other modules, <code>Frac5.Pnm</code> for reading and writing <a
href="https://en.wikipedia.org/wiki/Netpbm">Netpbm</a> image files, and
<code>Frac5.Extract</code>, for computing a <code>zcolor</code> unit
vector from an input image, but we will not delve into those two modules
here.</p>
<h2 id="frac5.affine"><code>Frac5.Affine</code></h2>
<div class="sourceCode" id="cb1"><pre
class="sourceCode elixir"><code class="sourceCode elixir"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">defmodule</span> <span class="cn">Frac5</span><span class="op">.</span><span class="cn">Affine</span> <span class="kw">do</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> <span class="cn">Nx</span><span class="op">.</span><span class="cn">Defn</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">defstruct</span> <span class="va">matrix:</span> <span class="cn">nil</span>, <span class="va">txform:</span> <span class="cn">nil</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi2</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="va">:math</span><span class="op">.</span>acos<span class="fu">(</span><span class="op">-</span><span class="fl">1.0</span><span class="fu">)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi4</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="ot">@pi2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi10</span> <span class="fl">5.0</span> <span class="op">*</span> <span class="ot">@pi2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  defn affine_tx<span class="fu">(</span>matrix, pts<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Nx</span><span class="op">.</span>remainder<span class="fu">(</span><span class="cn">Nx</span><span class="op">.</span>dot<span class="fu">(</span>pts, matrix<span class="fu">)</span> <span class="op">+</span> <span class="ot">@pi10</span>, <span class="ot">@pi4</span><span class="fu">)</span> <span class="op">-</span> <span class="ot">@pi2</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> generate<span class="fu">(</span>scale<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    variance <span class="op">=</span> scale <span class="op">*</span> scale</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    matrix <span class="op">=</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span> _i <span class="op">&lt;-</span> <span class="dv">0</span><span class="op">..</span><span class="dv">4</span> <span class="kw">do</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> _j <span class="op">&lt;-</span> <span class="dv">0</span><span class="op">..</span><span class="dv">4</span> <span class="kw">do</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>          <span class="va">:rand</span><span class="op">.</span>normal<span class="fu">(</span><span class="fl">0.0</span>, variance<span class="fu">)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">|&gt;</span> <span class="cn">Nx</span><span class="op">.</span>tensor<span class="fu">()</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    %<span class="cn">Frac5</span><span class="op">.</span><span class="cn">Affine</span><span class="fu">{</span><span class="va">matrix:</span> matrix, <span class="va">txform:</span> <span class="kw">fn</span> pts <span class="op">-&gt;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>      affine_tx<span class="fu">(</span>matrix, pts<span class="fu">)</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span><span class="fu">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> generate_stream_init<span class="fu">(</span>n, scale, txfms \\ <span class="ot">[]</span><span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    affs <span class="op">=</span> <span class="cn">Enum</span><span class="op">.</span>map<span class="fu">(</span><span class="dv">1</span><span class="op">..</span>n, <span class="kw">fn</span> _i <span class="op">-&gt;</span> generate<span class="fu">(</span>scale<span class="fu">)</span> <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    init_points <span class="op">=</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>      <span class="cn">Enum</span><span class="op">.</span>flat_map<span class="fu">(</span>affs, <span class="kw">fn</span> aff <span class="op">-&gt;</span> <span class="cn">Nx</span><span class="op">.</span>to_list<span class="fu">(</span>aff<span class="op">.</span>matrix<span class="fu">)</span> <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>      <span class="op">|&gt;</span> <span class="cn">Nx</span><span class="op">.</span>tensor<span class="fu">()</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>      <span class="op">|&gt;</span> <span class="cn">Nx</span><span class="op">.</span>multiply<span class="fu">(</span><span class="fl">1.0</span> <span class="op">/</span> scale<span class="fu">)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    txforms <span class="op">=</span> interleave<span class="fu">(</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>      <span class="cn">Enum</span><span class="op">.</span>map<span class="fu">(</span>affs, <span class="kw">fn</span> aff <span class="op">-&gt;</span> aff<span class="op">.</span>txform <span class="kw">end</span><span class="fu">)</span>,</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>      txfms<span class="fu">)</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    stream <span class="op">=</span> <span class="cn">Stream</span><span class="op">.</span>cycle<span class="fu">(</span>txforms<span class="fu">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span>stream, init_points<span class="fu">}</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Declaring <code>import Nx.Defn</code> allows us to use the Numerical
Elixir numerical function definition</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode elixir"><code class="sourceCode elixir"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  defn affine_tx<span class="fu">(</span>matrix, pts<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span></code></pre></div>
<p>which is notably not equivalent to a standard Elixir function
definition. Instead, this form is meant to declare functions of
Numerical Elixir tensor objects, which can be compiled to run on
whatever backend is configured. The semantics of operations inside an
<code>Nx</code> numerical function are handled differently: for example,
notice that we use the <code>+</code> symbol to add a floating point
constant to a tensor, which would raise an error if it were attempted in
ordinary Elixir code.</p>
<p>You may also note that we define the affine transformation a little
differently than the simple formula provided in the earlier discussion.
This is because I chose to define the five-dimensional space in which
all our operations take place to be a hyper-toroid, with the space
wrapping around at fixed boundaries in each dimension. All coordinates
are constrained to fall in the range <span class="math inline">\([-2\pi,
2\pi]\)</span>, and any coordinate which would fall outside that range,
is reinterpreted modulo <span class="math inline">\(4\pi\)</span>, to
fall back inside the range.</p>
<p>The <code>generate_stream_init()</code> function will usually be the
main entry point for this module. It creates an infinite (lazy) stream
of linear transformations, repeating every <code>n</code> linear steps,
possibly interleaved with a likewise repeating list of other
transformations supplied by the programmer. It returns this infinite
stream, along with a set of initial points, which are constructed by
simply taking the rows of the generated matrices.</p>
<p>(Note that <code>interleave</code> is a private function to this
module, which does just what the name suggests: accepts two lists as
arguments, and generates a list by interleaving available values from
each of its two inputs until <em>both</em> inputs are exhausted.)</p>
<h2 id="frac5.transforms"><code>Frac5.Transforms</code></h2>
<div class="sourceCode" id="cb3"><pre
class="sourceCode elixir"><code class="sourceCode elixir"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">defmodule</span> <span class="cn">Frac5</span><span class="op">.</span><span class="cn">Transforms</span> <span class="kw">do</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> <span class="cn">Nx</span><span class="op">.</span><span class="cn">Defn</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi2</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="va">:math</span><span class="op">.</span>acos<span class="fu">(</span><span class="op">-</span><span class="fl">1.0</span><span class="fu">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi4</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="ot">@pi2</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi10</span> <span class="fl">5.0</span> <span class="op">*</span> <span class="ot">@pi2</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  defn expand<span class="fu">(</span>pts<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    s2 <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>sum<span class="fu">(</span>pts <span class="op">*</span> pts, <span class="va">axes:</span> <span class="ot">[</span><span class="op">-</span><span class="dv">1</span><span class="ot">]</span>, <span class="va">keep_axes:</span> <span class="cn">true</span><span class="fu">)</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Nx</span><span class="op">.</span>remainder<span class="fu">(</span>pts <span class="op">+</span> <span class="cn">Nx</span><span class="op">.</span>pow<span class="fu">(</span>s2, <span class="fl">0.25</span><span class="fu">)</span> <span class="op">+</span> <span class="ot">@pi10</span>, <span class="ot">@pi4</span><span class="fu">)</span> <span class="op">-</span> <span class="ot">@pi2</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  defn contract<span class="fu">(</span>pts<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    s2 <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>sum<span class="fu">(</span>pts <span class="op">*</span> pts, <span class="va">axes:</span> <span class="ot">[</span><span class="op">-</span><span class="dv">1</span><span class="ot">]</span>, <span class="va">keep_axes:</span> <span class="cn">true</span><span class="fu">)</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    pts <span class="op">*</span> <span class="cn">Nx</span><span class="op">.</span>pow<span class="fu">(</span>s2, <span class="op">-</span><span class="fl">0.33</span><span class="fu">)</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  defn wmean<span class="fu">(</span>pts<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Nx</span><span class="op">.</span>window_mean<span class="fu">(</span>pts, <span class="fu">{</span><span class="dv">2</span>, <span class="dv">1</span><span class="fu">}</span>, <span class="va">padding:</span> <span class="va">:same</span><span class="fu">)</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  defn sin2<span class="fu">(</span>pts<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="fl">2.0</span> <span class="op">*</span> <span class="cn">Nx</span><span class="op">.</span>sin<span class="fu">(</span>pts<span class="fu">)</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> default_parallels<span class="fu">()</span> <span class="kw">do</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="ot">[</span><span class="op">&amp;</span>expand<span class="op">/</span><span class="dv">1</span>, <span class="op">&amp;</span>contract<span class="op">/</span><span class="dv">1</span>, <span class="op">&amp;</span><span class="cn">Nx</span><span class="op">.</span>cos<span class="op">/</span><span class="dv">1</span><span class="ot">]</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@chunk_limit</span> <span class="dv">100_000</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> points_stream<span class="fu">(</span>txform_stream, init_points, parallels<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Stream</span><span class="op">.</span>transform<span class="fu">(</span>txform_stream, <span class="ot">[</span>init_points<span class="ot">]</span>, <span class="kw">fn</span> txform, pts_stream <span class="op">-&gt;</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>      next_stream <span class="op">=</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Stream</span><span class="op">.</span>flat_map<span class="fu">(</span>pts_stream, <span class="kw">fn</span> pts <span class="op">-&gt;</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>          <span class="fu">{</span>n, _<span class="fu">}</span> <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>shape<span class="fu">(</span>pts<span class="fu">)</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> n <span class="op">&gt;=</span> <span class="ot">@chunk_limit</span> <span class="kw">do</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Enum</span><span class="op">.</span>map<span class="fu">(</span>parallels, <span class="kw">fn</span> par <span class="op">-&gt;</span> txform<span class="op">.</span><span class="fu">(</span>par<span class="op">.</span><span class="fu">(</span>pts<span class="fu">))</span> <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>            ppts <span class="op">=</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>              <span class="cn">Enum</span><span class="op">.</span>map<span class="fu">(</span>parallels, <span class="kw">fn</span> par <span class="op">-&gt;</span> par<span class="op">.</span><span class="fu">(</span>pts<span class="fu">)</span> <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>              <span class="op">|&gt;</span> <span class="cn">Nx</span><span class="op">.</span>concatenate<span class="fu">()</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>            <span class="ot">[</span>txform<span class="op">.</span><span class="fu">(</span>ppts<span class="fu">)</span><span class="ot">]</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>          <span class="kw">end</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>      <span class="fu">{</span>next_stream, next_stream<span class="fu">}</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Note that the <code>expand</code> function is a bit different than
the transformation from <em>AFC5</em>: not only does it apply the
wrapping behavior to <span class="math inline">\([-2\pi,2\pi]\)</span>,
but the power applied is <span class="math inline">\(1/4\)</span>
instead of <span class="math inline">\(1/3\)</span>. There are many such
detailed choices open to one generating these fascinating images: the
user of this library can easily supply their own function definitions.
There is also a <code>contract</code> function which I found
interesting, as well as the <code>wmean</code>, which simply averages
every two adjacent points in its input. Twice the <code>sin</code>
function still makes an appearance, but the defaults I wrote use
<code>cos</code> instead. Again, the point is not to repeat exactly the
same image generation techniques, but to experiment and find what is
most interesting in the moment.</p>
<p>The main utility function here is <code>points_stream()</code>, which
accepts as arguments a stream of transforms, a tensor of initial points,
and the (usually non-linear) list of functions to be applied to expand
the set of points exponentially. The first two arguments would usually
be expected to be generated by the
<code>Frac5.Affine.generate_stream_init()</code> function. The
<code>points_stream</code> function, as the name suggests, returns a
stream of tensors of points, where once there are more than
<code>@chunk_size 100_000</code> points in a tensor, they will no longer
be concatenated to make larger tensors, but streamed instead.</p>
<h2 id="frac5.pixels"><code>Frac5.Pixels</code></h2>
<div class="sourceCode" id="cb4"><pre
class="sourceCode elixir"><code class="sourceCode elixir"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">defmodule</span> <span class="cn">Frac5</span><span class="op">.</span><span class="cn">Pixels</span> <span class="kw">do</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> <span class="cn">Nx</span><span class="op">.</span><span class="cn">Defn</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> rand_unit_vec<span class="fu">(</span>dim<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    l <span class="op">=</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span> _i <span class="op">&lt;-</span> <span class="dv">1</span><span class="op">..</span>dim <span class="kw">do</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">:rand</span><span class="op">.</span>normal<span class="fu">(</span><span class="fl">0.0</span>, <span class="fl">1.0</span><span class="fu">)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    norm <span class="op">=</span> <span class="va">:math</span><span class="op">.</span>sqrt<span class="fu">(</span><span class="cn">Enum</span><span class="op">.</span>reduce<span class="fu">(</span>l, <span class="dv">0</span>, <span class="kw">fn</span> v, sum <span class="op">-&gt;</span> sum <span class="op">+</span> v <span class="op">*</span> v <span class="kw">end</span><span class="fu">))</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Enum</span><span class="op">.</span>map<span class="fu">(</span>l, <span class="kw">fn</span> v <span class="op">-&gt;</span> v <span class="op">/</span> norm <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">|&gt;</span> <span class="cn">Nx</span><span class="op">.</span>tensor<span class="fu">()</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi2</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="va">:math</span><span class="op">.</span>acos<span class="fu">(</span><span class="op">-</span><span class="fl">1.0</span><span class="fu">)</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@pi4</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="ot">@pi2</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">@resolution</span> <span class="dv">2048</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  defn pixel_reducer<span class="fu">(</span>pts, <span class="fu">{</span>grid, count<span class="fu">}</span>, zcolor<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    dim <span class="op">=</span> <span class="ot">@resolution</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span>npts, <span class="dv">5</span><span class="fu">}</span> <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>shape<span class="fu">(</span>pts<span class="fu">)</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    rgbs <span class="op">=</span> pts<span class="ot">[[</span><span class="op">..</span>, <span class="dv">2</span><span class="op">..</span><span class="dv">4</span><span class="ot">]]</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    dots <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>dot<span class="fu">(</span>rgbs, zcolor<span class="fu">)</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    rgbs <span class="op">=</span> rgbs <span class="op">-</span> <span class="cn">Nx</span><span class="op">.</span>outer<span class="fu">(</span>dots, zcolor<span class="fu">)</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    xys <span class="op">=</span> pts<span class="ot">[[</span><span class="op">..</span>, <span class="dv">0</span><span class="op">..</span><span class="dv">1</span><span class="ot">]]</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>as_type<span class="fu">(</span><span class="cn">Nx</span><span class="op">.</span>floor<span class="fu">(</span>dim <span class="op">*</span> <span class="fu">(</span>xys <span class="op">+</span> <span class="ot">@pi2</span><span class="fu">)</span> <span class="op">/</span> <span class="ot">@pi4</span><span class="fu">)</span>, <span class="va">:s16</span><span class="fu">)</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>clip<span class="fu">(</span>indices, <span class="dv">0</span>, dim <span class="op">-</span> <span class="dv">1</span><span class="fu">)</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    grid <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>indexed_add<span class="fu">(</span>grid, indices, rgbs<span class="fu">)</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>indexed_add<span class="fu">(</span>count, indices, <span class="cn">Nx</span><span class="op">.</span>broadcast<span class="fu">(</span><span class="dv">1</span>, <span class="fu">{</span>npts, <span class="dv">1</span><span class="fu">}))</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span>grid, count<span class="fu">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  defn color_bytes<span class="fu">(</span>grid, count<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Nx</span><span class="op">.</span>as_type<span class="fu">(</span><span class="fl">127.5</span> <span class="op">*</span> <span class="fu">(</span><span class="fl">1.0</span> <span class="op">-</span> <span class="cn">Nx</span><span class="op">.</span>cos<span class="fu">(</span>grid <span class="op">/</span> count<span class="fu">))</span>, <span class="va">:u8</span><span class="fu">)</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> pixelate<span class="fu">(</span>points, zcolor, batches<span class="fu">)</span> <span class="kw">do</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    dim <span class="op">=</span> <span class="ot">@resolution</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    grid0 <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>broadcast<span class="fu">(</span><span class="fl">0.0</span>, <span class="fu">{</span>dim, dim, <span class="dv">3</span><span class="fu">})</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    count0 <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>broadcast<span class="fu">(</span><span class="dv">0</span>, <span class="fu">{</span>dim, dim, <span class="dv">1</span><span class="fu">})</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span>grid, count<span class="fu">}</span> <span class="op">=</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>      <span class="cn">Stream</span><span class="op">.</span>take<span class="fu">(</span>points, batches<span class="fu">)</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>      <span class="op">|&gt;</span> <span class="cn">Enum</span><span class="op">.</span>reduce<span class="fu">({</span>grid0, count0<span class="fu">}</span>, <span class="kw">fn</span> pts, <span class="fu">{</span>grid, count<span class="fu">}</span> <span class="op">-&gt;</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        pixel_reducer<span class="fu">(</span>pts, <span class="fu">{</span>grid, count<span class="fu">}</span>, zcolor<span class="fu">)</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span><span class="fu">)</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="cn">IO</span><span class="op">.</span>inspect<span class="fu">(</span><span class="cn">Nx</span><span class="op">.</span>to_number<span class="fu">(</span><span class="cn">Nx</span><span class="op">.</span>sum<span class="fu">(</span>count<span class="fu">)))</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="cn">Nx</span><span class="op">.</span>clip<span class="fu">(</span>count, <span class="dv">1</span>, <span class="dv">2_000_000</span> <span class="op">*</span> batches<span class="fu">)</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    color_bytes<span class="fu">(</span>grid, count<span class="fu">)</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The main entry point here is <code>pixelate</code>, which accepts a
stream of tensors of points, as may be generated by
<code>Frac5.Transforms.points_stream()</code>, a <code>zcolor</code>
3-vector to project out of the color space, and a number of
<code>batches</code> to collect from the input stream (which, after all,
may be infinite). It generates a pixel grid as a tensor of dimensions
<code>{2048, 2048, 3}</code>, chosen arbitrarily enough, maps the <span
class="math inline">\([-2\pi,2\pi]\)</span> range of the spatial
coordinates to <span class="math inline">\([0,2047]\)</span>, and uses
the function <span class="math inline">\(255(1 - \cos(c))/2\)</span> to
map the color coordinates to <span class="math inline">\([0,
255]\)</span>. It takes the average of the color coordinates of all of
the points which fall in a pixel, to determine the color for the pixel.
Most of the numerical work here takes place in the
<code>pixel_reducer()</code> numerical function.</p>
<h1 id="future-plans">Future Plans</h1>
<p>There are many interesting directions one could take this work. One
approach would be to look at the alternation of linear and non-linear
transformations as an unusual kind of neural net, and ask, how might we
train such a network, to generate especially interesting images? I have
briefly investigated this option, without identifying a loss function I
found useful. Another direction I hope to explore, is making the process
of creating these images more dynamic or interactive, perhaps by using
<code>WebGPU</code> in the browser. It may prove fruitful, having
identified a set of matrices which look quite exciting, to be able to
tune the values of those matrices to optimize the result. Most of all,
though, I hope to inspire others to go forth and write programs which
generate beauty!</p>
<figure>
<img src="/images/fractal447.png" alt="closing fractal image" />
<figcaption aria-hidden="true">closing fractal image</figcaption>
</figure>
</body>
</html>
