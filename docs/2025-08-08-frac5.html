<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-08-08" />
  <title>Frac5: A new type of flame fractal</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="/pbb.css" />
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,400i,700,700i|Source+Sans+Pro:400,400i,700,700i&display=swap" rel="stylesheet">
  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="kfrost Feed">
  <link rel="icon" href="/favicon.png" sizes="32x32" type="image/png">
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
<div id="blogtitle"><a href="./">kfrost</a></div>
<header id="title-block-header">
<h1 class="title">Frac5: A new type of flame fractal</h1>
<p class="date">2025-08-08</p>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">table of contents</h2>
<ul>
<li><a href="#iterated-function-systems"
id="toc-iterated-function-systems">Iterated function systems</a></li>
<li><a href="#porting-to-numerical-elixir"
id="toc-porting-to-numerical-elixir">Porting to Numerical
Elixir</a></li>
</ul>
</nav>
<figure>
<img src="/images/fractal255.png" alt="example frac5 fractal image" />
<figcaption aria-hidden="true">example frac5 fractal image</figcaption>
</figure>
<p>This article describes my journey from generating flame fractals
using <a href="https://elixir-lang">Elixir</a>, to generating a new type
of (flame-ish?) fractal in <a
href="https://github.com/elixir-nx">Numerical Elixir</a>. The code is
published as a GPL Elixir library at <a
href="https://github.com/KeithFrost/frac5">github.com/KeithFrost/frac5</a>.</p>
<p>This summer I’ve been working on personal projects at the <a
href="https://recurse.com">Recurse Center</a> (RC). Part of the RC
application process involves pitching at least one project that you plan
to work on. The <a href="https://github.com/KeithFrost/frac5">frac5</a>
project was inspired by the pitch I wrote for my RC application.</p>
<p>To give due credit, the work I describe here would not exist without
Danielle Navarro’s terrific article <a
href="https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/">Art
from code V: Iterated function systems</a> (hereinafter referred to as
<em>AFC5</em>); I’m going to summarize only those parts of their article
which I used for my starting point, but I encourage you to read the
whole thing for edification and inspiration.</p>
<p>I had been using <a href="https://elixir-lang">Elixir</a> for
personal projects for a while, because I find programming with it
elegant and fun; I especially enjoy prototyping code using <a
href="https://livebook.dev">Elixir Livebook</a> running locally. I had
read about <a href="https://github.com/elixir-nx">Numerical Elixir</a>,
which extends the language to make it possible to perform the kind of
efficient numerical programming often done with <a
href="https://numpy.org">NumPy</a>, <a
href="https://pytorch.org">PyTorch</a>, or similar libraries, but I had
not found a use case to motivate learning how to program it myself. I
came across <a
href="https://blog.djnavarro.net/posts/2024-12-22_art-from-code-5/"><em>AFC5</em></a>,
enjoyed the beautiful images they were able to generate (especially
those at the end of the article), and was a little uncomfortable about
needing to resort to writing C++ to generate those detailed images
quickly. My initial plan was to retrace their steps using only Elixir,
and then explore if there was some way to use Numerical Elixir to
accelerate the image generation.</p>
<h1 id="iterated-function-systems">Iterated function systems</h1>
<p>I will now briefly recap how the beautiful images at the end of
<em>AFC5</em> are generated, although if you want to reproduce all the
details from that article precisely, you should of course refer to it,
and the code it provides, directly.</p>
<p>Those images are generated by starting with a single point <span
class="math inline">\(p_0\)</span> in a three-dimensional space <span
class="math inline">\({p_0 \equiv (x_0, y_0, z_0)}\)</span>. In what
follows, we will refer to the coordinates of these points by a second
index, so we have <span class="math display">\[
p_0 \equiv (p_{0,0}, p_{0,1}, p_{0,2}) \equiv (x_0, y_0, z_0)
\]</span></p>
<p>The point <span class="math inline">\(p_0\)</span> is then passed
through a series of transformations, alternating between linear and
non-linear steps, and after each non-linear step, the resulting point is
added into the collection of points to be rendered.</p>
<p>In effect, we generate a collection of points <span
class="math inline">\(\{p_k\}, k=0,1,2,...\)</span>, where <span
class="math display">\[
p_{k} = f_k\left( \sum_j A_{k,i,j} \cdot p_{k-1,j} \right).
\]</span> The meaning of the linear transformation here should be clear:
<span class="math display">\[
q_{k,i} = \sum_{j=0}^2 A_{k,i,j} \cdot p_{k-1,j}, i = 0,1,2.
\]</span> defines a new 3-D vector <span
class="math inline">\(q_k\)</span> by multiplying the 3-D vector <span
class="math inline">\(p_{k-1}\)</span> by a <span
class="math inline">\(3 \times 3\)</span> matrix <span
class="math inline">\(A_k\)</span>. What we mean by <span
class="math inline">\(p_k = f_k(q_{k,i})\)</span> perhaps needs some
clarification. The general function <span
class="math inline">\(f_k\)</span> is understood to accept as arguments
<em>all three of the components</em> of the 3-D vector <span
class="math inline">\(q_k\)</span>, and return <em>all three of the
components</em> of the 3-D vector <span
class="math inline">\(p_k\)</span>.</p>
<p>In the iterated systems discussed at the end of <em>AFC5</em>, the
transformation matrix <span class="math inline">\(A_k\)</span> at each
stage <span class="math inline">\(k = 1,2,3,...\)</span> is randomly
chosen from a set of matrices <span class="math inline">\(\{M_q\},
q=1,2,...m\)</span>, and the function <span
class="math inline">\(f_k(q_k)\)</span> is likewise randomly chosen from
a set of non-linear transformations <span
class="math inline">\(\{G_r(q)\}\)</span>, defined in <em>AFC5</em> as
<span class="math display">\[
\begin{align}
G_{0,i}(q) &amp;= q_i + \left( \sum_j q_j^2 \right)^{1/3} \\
G_{1,i}(q) &amp;= \sin(q_i) \\
G_{2,i}(q) &amp;= 2 \cdot \sin(q_i)
\end{align}
\]</span></p>
<p>I have taken the liberty here of eliding some manipulations performed
in the original <em>AFC5</em> article, which treat the <span
class="math inline">\(z\)</span> coordinate of the points specially, to
ensure that the <span class="math inline">\(z\)</span> coordinate always
remains non-negative, and to average the new <span
class="math inline">\(z\)</span> coordinate <span
class="math inline">\(p_{k,2}\)</span> with its previous value <span
class="math inline">\(p_{k-1,2}\)</span> before finalizing its value.
These details might be important if you wish to reproduce the results of
that article in detail, but for understanding the extension of that work
to follow, it seems best to me to treat all dimensions of the vector
space symmetrically, until we are ready to render the pixel data of the
image.</p>
<p>Speaking of being ready to render pixel data, we have seen how we can
generate an arbitrarily large collection of points <span
class="math inline">\(\{p_k\},
k=0,1,2,...\)</span>, but how do we turn those points into an image? In
the algorithm described in <em>ACS5</em>, we transform the <span
class="math inline">\((x, y)\)</span> coordinates of the points into
indices of a two-dimensional pixel array, and then, if those indices
fall within the bounds of the array, set the color of the pixel
referenced by those indices to a value determined by some chosen palette
for converting <span class="math inline">\(z\)</span> values to
colors.</p>
<p>I found I was able to reproduce, as closely as I wished, the work in
<em>ACS5</em>, by writing code in ordinary Elixir (without using
Numerical Elixir), and it performed well enough to generate some lovely
images within acceptable times. For example:</p>
<figure>
<img src="/images/fractal002.png" alt="early example fractal" />
<figcaption aria-hidden="true">early example fractal</figcaption>
</figure>
<p>As soon as I was able to generate this image (and several others like
it), I became tremendously excited by the potential of the project. I
knew that there was much more work I could explore along these lines, by
investigating each of the choices that went into creating the images,
and finding ways to either optimize the implementation, or expand the
range of choices available for artistic purposes. But more than that, I
was supremely motivated by the surprising and spectacular beauty of the
generated pictures, especially when combined with the stark mathematical
simplicity of the means of generating them. To put it bluntly, I was
hooked.</p>
<h1 id="porting-to-numerical-elixir">Porting to Numerical Elixir</h1>
<p>While it is possible to generate interesting and beautiful images
using only a few million points using the scheme described in
<em>ACS5</em>, more subtle and complex textures become possible by
scaling the number of points up to hundreds of millions. And while it is
possible to process such large numbers of points on a CPU using a
language like Elixir, such “number-crunching” applications are not the
forte of the language, and it soon becomes tedious to wait for the image
generation process. The author of <em>ACS5</em> opted to port the
algorithm to C++ to achieve better speed; I wanted to find out if it
might be possible to do so using the features of Numerical Elixir,
especially with a backend programmed to use a GPU.</p>
<p>I quickly realized that there was a significant obstacle to achieving
a significant performance improvement of the fractal algorithm presented
above using <code>Nx</code>, particularly on the GPU. Many of the
performance benefits achieved by libraries like <code>Nx</code>, which
manipulate numbers in large, often multi-dimensional arrays, come from
being able to compute operations on many elements of these arrays <em>in
parallel</em>. This is <em>especially</em> true for the performance
enhancements provided by using the GPU. But recall the algorithm
presented above, in which we might wish to process hundreds of millions
of points <span class="math inline">\(\{p_k\},
k=0,1,2...\)</span>, defined <em>in sequence</em> by some transformation
<span class="math inline">\(p_{k-1}
\rightarrow p_k\)</span>. If the components of each point <span
class="math inline">\(p_k\)</span> depend on some random choices <em>and
the components of the preceding point</em> <span
class="math inline">\(p_{k-1}\)</span>, we cannot achieve any high
degree of parallelism of the processing of these points, since a
processor (either CPU or GPU) cannot process a point until the values
from the preceding point (and the random choices) are available.</p>
<p>One means of circumventing this difficulty would seem to be, to
replace the single starting point <span
class="math inline">\(p_0\)</span> with an ensemble of starting points,
and to achieve the efficiencies of parallelism by collecting ensembles
of points processed through the steps of the algorithm in parallel.
Unfortunately, my experiments with implementing this approach convinced
me that the results did not successfully reproduce the aesthetic
features of the beautiful images generated by the original
algorithm.</p>
<p>Instead, inspired by another variation on the algorithm I had
explored, I decided to try something else. Recall above that there were
two distinct random choices made for each transformation of the points:
first, a random matrix was chosen for the linear transformation, and
second, a random non-linear transformation was chosen. I had already
experimented with replacing the random choice of matrix with a simple
repeating sequence of matrices. To transform the point <span
class="math inline">\(p_k\)</span>, for example, we might use the matrix
<span class="math inline">\(M_{k
\bmod m}\)</span>, where <span class="math inline">\(m\)</span> is the
number of random matrices initially generated. This gave results which
were just as beautiful as the random choice algorithm.</p>
<p>So when I thought about how to make the algorithm more suitable to
parallel computation, I was already primed to consider modifying the
random choice rule. In particular, I opted to try, instead of randomly
choosing <em>one</em> of the non-linear transformations available, to
always perform <em>all</em> of the non-linear transformations, and to
add all of the points thus generated, both to the set of points used to
render the image, and to an ensemble of points to be passed to the next
stage of the algorithm. This means that the number of points in the
ensemble at each stage of the algorithm grows exponentially with each
such application of the non-linear transformations. When the ensemble of
points grows sufficiently large, I split it up into batches, in order to
avoid having any one block of memory need to be too large. Since blocks
of points can be discarded once they are accumulated into the grid used
to generate the image pixels, and Elixir allows me to generate a lazy
stream of blocks of points for accumulation into the grid, this helps to
keep memory usage of the program at any one time under control.</p>
<p>I found removing all of the random choices from the execution of the
algorithm in this way both aesthetically and intellectually pleasing. I
now had a <em>deterministic</em> algorithm for generating beautiful
images, given only a sequence of <span class="math inline">\(3 \times
3\)</span> matrices, a set of arbitrary (usually non-linear) point
transformations to be applied, and a color palette for mapping <span
class="math inline">\(z\)</span> values to colors. Moreover, the
algorithm could be made to transform enormous numbers of points in
parallel, opening the door to making it possible to accelerate it by
running on GPU hardware. But I still wasn’t quite satisfied with the
generality of the mathematics. In particular, I wanted to use a wider
variety of color palettes than those I had yet defined, and I was
uncomfortable with the tedium and what seemed to me the arbitrariness of
the choices involved in creating new palettes.</p>
<p>One day I went for a walk, and reflected on how I might remove the
need to define a color palette for rendering. After a couple miles of
walking, I was struck with an idea. Instead of a three dimensional space
<span class="math inline">\((x,y,z)\)</span>, I would process points in
a completely analogous way, but in a five dimensional space <span
class="math inline">\((x,y,r,g,b)\)</span>. When it came time to render
these points to pixel colors, all I would need is a single choice of
mapping function from color space coordinate to the corresponding range
of pixel values (<em>e.g.</em> <span
class="math inline">\([0,255]\)</span>). Below is the very first image I
generated using this new scheme.</p>
<figure>
<img src="/images/fractal041.png" alt="first 5-D fractal image" />
<figcaption aria-hidden="true">first 5-D fractal image</figcaption>
</figure>
</body>
</html>
